/* ***************************************************
 * 文件名：  crc.c
 * 模  块： CRC校验模块。
 * 详  述：
 *        提供CRC校验计算函数。
 *
 *  Copyright (C) 2017 Henan Thinker Co.,Ltd. All rights reserved.
 *  版权所有:河南思维轨道交通技术研究院有限公司，所有权利保留。
 * 
 ****************************************************/
#include "crc.h"
#include "string.h"

/** 根据配置的32位多项式生成的计算表 */
static uint32_t cfged_tab32[256];

static const uint16_t crctab16[] =\
{
  0x0000U, 0x1189U, 0x2312U, 0x329bU, 0x4624U, 0x57adU, 0x6536U, 0x74bfU,
  0x8c48U, 0x9dc1U, 0xaf5aU, 0xbed3U, 0xca6cU, 0xdbe5U, 0xe97eU, 0xf8f7U,
  0x1081U, 0x0108U, 0x3393U, 0x221aU, 0x56a5U, 0x472cU, 0x75b7U, 0x643eU,
  0x9cc9U, 0x8d40U, 0xbfdbU, 0xae52U, 0xdaedU, 0xcb64U, 0xf9ffU, 0xe876U,
  0x2102U, 0x308bU, 0x0210U, 0x1399U, 0x6726U, 0x76afU, 0x4434U, 0x55bdU,
  0xad4aU, 0xbcc3U, 0x8e58U, 0x9fd1U, 0xeb6eU, 0xfae7U, 0xc87cU, 0xd9f5U,
  0x3183U, 0x200aU, 0x1291U, 0x0318U, 0x77a7U, 0x662eU, 0x54b5U, 0x453cU,
  0xbdcbU, 0xac42U, 0x9ed9U, 0x8f50U, 0xfbefU, 0xea66U, 0xd8fdU, 0xc974U,
  0x4204U, 0x538dU, 0x6116U, 0x709fU, 0x0420U, 0x15a9U, 0x2732U, 0x36bbU,
  0xce4cU, 0xdfc5U, 0xed5eU, 0xfcd7U, 0x8868U, 0x99e1U, 0xab7aU, 0xbaf3U,
  0x5285U, 0x430cU, 0x7197U, 0x601eU, 0x14a1U, 0x0528U, 0x37b3U, 0x263aU,
  0xdecdU, 0xcf44U, 0xfddfU, 0xec56U, 0x98e9U, 0x8960U, 0xbbfbU, 0xaa72U,
  0x6306U, 0x728fU, 0x4014U, 0x519dU, 0x2522U, 0x34abU, 0x0630U, 0x17b9U,
  0xef4eU, 0xfec7U, 0xcc5cU, 0xddd5U, 0xa96aU, 0xb8e3U, 0x8a78U, 0x9bf1U,
  0x7387U, 0x620eU, 0x5095U, 0x411cU, 0x35a3U, 0x242aU, 0x16b1U, 0x0738U,
  0xffcfU, 0xee46U, 0xdcddU, 0xcd54U, 0xb9ebU, 0xa862U, 0x9af9U, 0x8b70U,
  0x8408U, 0x9581U, 0xa71aU, 0xb693U, 0xc22cU, 0xd3a5U, 0xe13eU, 0xf0b7U,
  0x0840U, 0x19c9U, 0x2b52U, 0x3adbU, 0x4e64U, 0x5fedU, 0x6d76U, 0x7cffU,
  0x9489U, 0x8500U, 0xb79bU, 0xa612U, 0xd2adU, 0xc324U, 0xf1bfU, 0xe036U,
  0x18c1U, 0x0948U, 0x3bd3U, 0x2a5aU, 0x5ee5U, 0x4f6cU, 0x7df7U, 0x6c7eU,
  0xa50aU, 0xb483U, 0x8618U, 0x9791U, 0xe32eU, 0xf2a7U, 0xc03cU, 0xd1b5U,
  0x2942U, 0x38cbU, 0x0a50U, 0x1bd9U, 0x6f66U, 0x7eefU, 0x4c74U, 0x5dfdU,
  0xb58bU, 0xa402U, 0x9699U, 0x8710U, 0xf3afU, 0xe226U, 0xd0bdU, 0xc134U,
  0x39c3U, 0x284aU, 0x1ad1U, 0x0b58U, 0x7fe7U, 0x6e6eU, 0x5cf5U, 0x4d7cU,
  0xc60cU, 0xd785U, 0xe51eU, 0xf497U, 0x8028U, 0x91a1U, 0xa33aU, 0xb2b3U,
  0x4a44U, 0x5bcdU, 0x6956U, 0x78dfU, 0x0c60U, 0x1de9U, 0x2f72U, 0x3efbU,
  0xd68dU, 0xc704U, 0xf59fU, 0xe416U, 0x90a9U, 0x8120U, 0xb3bbU, 0xa232U,
  0x5ac5U, 0x4b4cU, 0x79d7U, 0x685eU, 0x1ce1U, 0x0d68U, 0x3ff3U, 0x2e7aU,
  0xe70eU, 0xf687U, 0xc41cU, 0xd595U, 0xa12aU, 0xb0a3U, 0x8238U, 0x93b1U,
  0x6b46U, 0x7acfU, 0x4854U, 0x59ddU, 0x2d62U, 0x3cebU, 0x0e70U, 0x1ff9U,
  0xf78fU, 0xe606U, 0xd49dU, 0xc514U, 0xb1abU, 0xa022U, 0x92b9U, 0x8330U,
  0x7bc7U, 0x6a4eU, 0x58d5U, 0x495cU, 0x3de3U, 0x2c6aU, 0x1ef1U, 0x0f78U,
};

/*****************************************************
 * 功能：位逆转
 * 参数：in_u32 - 待逆转值
 * 参数：bw_u32 - 位宽
 * 返回：逆转后的值
 ******************************************************/
static uint32_t bitrev(uint32_t in_u32, uint32_t bw_u32)
{
    uint32_t i;
    uint32_t var_u32;

    var_u32 = 0U;
    for(i =0; i < bw_u32; i++)
    {
        if(in_u32 & 0x01U)
        {
            var_u32 |= 1 << (bw_u32 - 1 - i);
        }
        else
        {
          /** ntd. */
        }
        in_u32 >>= 1;
    }
    return var_u32;
}

/*****************************************************
 * 功能：生成计算表
 * 参数：poly_u32    - 计算多项式
 * 参数：*ptable_u32 - 计算表指针
 * 返回：无
 ******************************************************/
static void create_crc32_table(uint32_t poly_u32, uint32_t *ptable_u32)
{
  uint32_t i;
  uint32_t j;
  uint32_t c_u32;

  /** 多项式位逆转 */
  poly_u32 = bitrev(poly_u32, 32);
  for(i = 0; i < 256U; i++)
  {
    c_u32 = i;
    for(j = 0; j < 8U; j++)
    {
      if(c_u32 & 1U)
      {
        c_u32 = poly_u32 ^ (c_u32 >> 1U);
      }
      else
      {
        c_u32 = c_u32 >> 1U;
      }
    }
    /** 保存到计算表中 */
    ptable_u32[i] = c_u32;
  }
}

/*****************************************************
 * 功能：生成计算表
 * 参数：poly_u32    - 计算多项式
 * 返回：无
 ******************************************************/
void init_config_crc32(uint32_t poly_u32)
{
  create_crc32_table(poly_u32, cfged_tab32);
}

/*********************************************************
 * 功能：计算根据配置的多项式生成计算表的CRC32校验码
 * 参数：*pbuffer_u8-待计算数据缓冲区指针
 * 参数：length_u32 -待计算数据字节数
 * 参数：initval_u32-初始值
 * 返回：
 **********************************************************/
uint32_t crc32_cfged(uint8_t *pbuffer_u8, uint32_t length_u32, uint32_t initval_u32)
{
 uint32_t i;
 uint32_t crc32_u32 = initval_u32;

 for (i = 0; i < length_u32; i++)
 {
   crc32_u32 = (crc32_u32 >> 8) ^ (cfged_tab32[(crc32_u32 ^ *pbuffer_u8++) & 0xff]);
 }
 return crc32_u32;
}


/* crc8计算 */
uint8_t crc8_create(const uint8_t *p_dat_u8, uint16_t len_u16, uint8_t crc_init_val_u8)
{
  static const uint8_t st_a_crctab8[256] =
  {
    0x00, 0x5E, 0xBC, 0xE2, 0x61, 0x3F, 0xDD, 0x83, 0xC2, 0x9C, 0x7E, 0x20, 0xA3, 0xFD, 0x1F, 0x41, 
    0x9D, 0xC3, 0x21, 0x7F, 0xFC, 0xA2, 0x40, 0x1E, 0x5F, 0x01, 0xE3, 0xBD, 0x3E, 0x60, 0x82, 0xDC, 
    0x23, 0x7D, 0x9F, 0xC1, 0x42, 0x1C, 0xFE, 0xA0, 0xE1, 0xBF, 0x5D, 0x03, 0x80, 0xDE, 0x3C, 0x62, 
    0xBE, 0xE0, 0x02, 0x5C, 0xDF, 0x81, 0x63, 0x3D, 0x7C, 0x22, 0xC0, 0x9E, 0x1D, 0x43, 0xA1, 0xFF, 
    0x46, 0x18, 0xFA, 0xA4, 0x27, 0x79, 0x9B, 0xC5, 0x84, 0xDA, 0x38, 0x66, 0xE5, 0xBB, 0x59, 0x07, 
    0xDB, 0x85, 0x67, 0x39, 0xBA, 0xE4, 0x06, 0x58, 0x19, 0x47, 0xA5, 0xFB, 0x78, 0x26, 0xC4, 0x9A, 
    0x65, 0x3B, 0xD9, 0x87, 0x04, 0x5A, 0xB8, 0xE6, 0xA7, 0xF9, 0x1B, 0x45, 0xC6, 0x98, 0x7A, 0x24, 
    0xF8, 0xA6, 0x44, 0x1A, 0x99, 0xC7, 0x25, 0x7B, 0x3A, 0x64, 0x86, 0xD8, 0x5B, 0x05, 0xE7, 0xB9, 
    0x8C, 0xD2, 0x30, 0x6E, 0xED, 0xB3, 0x51, 0x0F, 0x4E, 0x10, 0xF2, 0xAC, 0x2F, 0x71, 0x93, 0xCD, 
    0x11, 0x4F, 0xAD, 0xF3, 0x70, 0x2E, 0xCC, 0x92, 0xD3, 0x8D, 0x6F, 0x31, 0xB2, 0xEC, 0x0E, 0x50, 
    0xAF, 0xF1, 0x13, 0x4D, 0xCE, 0x90, 0x72, 0x2C, 0x6D, 0x33, 0xD1, 0x8F, 0x0C, 0x52, 0xB0, 0xEE, 
    0x32, 0x6C, 0x8E, 0xD0, 0x53, 0x0D, 0xEF, 0xB1, 0xF0, 0xAE, 0x4C, 0x12, 0x91, 0xCF, 0x2D, 0x73, 
    0xCA, 0x94, 0x76, 0x28, 0xAB, 0xF5, 0x17, 0x49, 0x08, 0x56, 0xB4, 0xEA, 0x69, 0x37, 0xD5, 0x8B, 
    0x57, 0x09, 0xEB, 0xB5, 0x36, 0x68, 0x8A, 0xD4, 0x95, 0xCB, 0x29, 0x77, 0xF4, 0xAA, 0x48, 0x16, 
    0xE9, 0xB7, 0x55, 0x0B, 0x88, 0xD6, 0x34, 0x6A, 0x2B, 0x75, 0x97, 0xC9, 0x4A, 0x14, 0xF6, 0xA8, 
    0x74, 0x2A, 0xC8, 0x96, 0x15, 0x4B, 0xA9, 0xF7, 0xB6, 0xE8, 0x0A, 0x54, 0xD7, 0x89, 0x6B, 0x35, 
  }; 
  uint8_t crc_u8 = crc_init_val_u8;
  uint16_t i;
  
  for(i = 0U; i < len_u16; i++)
  {
    crc_u8 = st_a_crctab8[crc_u8 ^ p_dat_u8[i]];
  }
  return crc_u8;
}

/**
 * 生成CRC16校验码，多项式0x8005.
 * 
 * @param len    数据字节数
 * @param buf    生成校验码源数据缓冲区
 */

static uint16_t crc16_create(const uint8_t * p_dat_u8, uint16_t len, uint16_t crc)
{    
  static const uint16_t st_a_crctab16[256] =
  {
      0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241
    , 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440
    , 0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40
    , 0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841
    , 0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40
    , 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41
    , 0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641
    , 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040
    , 0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240
    , 0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441
    , 0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41
    , 0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840
    , 0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41
    , 0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40
    , 0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640
    , 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041
    , 0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240
    , 0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441
    , 0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41
    , 0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840
    , 0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41
    , 0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40
    , 0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640
    , 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041
    , 0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241
    , 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440
    , 0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40
    , 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841
    , 0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40
    , 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41
    , 0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641
    , 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040

  };  /* 表 */

  while(len > 0U) /* 剩余 */
  {
    crc = (uint16_t)((uint16_t)(crc >> 8U) ^ st_a_crctab16[*p_dat_u8 ^ (uint8_t)crc]);
    len--;        /* 长度减 */
    p_dat_u8++;   /* 指针变化 */
  }        

  return (crc);    /* 返回 */
}


/*******************************************************************************************
 ** @brief: Common_CRC16
 ** @param: pData: the data for CRC
	        nLength: the Length of data for CRC
*******************************************************************************************/
uint16_t Common_CRC16(uint8_t* pData, uint32_t nLength)
{
	uint32_t k;
	uint16_t crc = 0U;
	
  /* 30-August-2018, by Liang Zhen. */
  #if 0
	if ( nLength > 0xffffU )
  #else
  if ( ( NULL == pData ) || ( 0U == nLength ) )
  #endif
	{
		k = 0x17U;
		return ( 0U );
	} /* end if */
	
	while ( nLength > 0u )
	{
		k   = ( crc ^ *pData ) & 0xffU;
		crc = ( crc >> 8u ) ^ crctab16[ k ];
		nLength--;
		pData++;
	} /* end while */
  
	return ( ~crc );
}

/****************************************************************************************/
uint16_t  crc16l(uint8_t *ptr,uint8_t len)
{
	uint8_t  i = 0u;
	uint16_t crc = 0xFFFF;
	
	while(len--)
	{
		for(i=0x80u; i!=0; i>>=1)
		{
			if((crc&0x8000)!=0)
			{
				crc<<=1;
				crc^=0x1021;
			}
			else
				crc<<=1;
			if((*ptr&i)!=0)
				crc^=0x1021;
		}
		ptr++;
	}
	return crc;
}

/* 出栈 */
#pragma push
/* 优化等级 3 */
#pragma O3
/**
 * 生成CRC32校验码
 * 
 * @param len    数据字节长度
 * @param buf    生成校验码源数据缓冲区
 */
uint32_t crc32_create(const uint8_t * p_dat_u8, uint16_t len, uint32_t crc)
{
  /** 多项式 0x04C11DB7 */
  static const uint32_t  st_a_CRCTable32[256] =
  {
    0x00000000, 0x04C11DB7, 0x09823B6E, 0x0D4326D9, 0x130476DC, 0x17C56B6B, 0x1A864DB2, 0x1E475005
    , 0x2608EDB8, 0x22C9F00F, 0x2F8AD6D6, 0x2B4BCB61, 0x350C9B64, 0x31CD86D3, 0x3C8EA00A, 0x384FBDBD
    , 0x4C11DB70, 0x48D0C6C7, 0x4593E01E, 0x4152FDA9, 0x5F15ADAC, 0x5BD4B01B, 0x569796C2, 0x52568B75
    , 0x6A1936C8, 0x6ED82B7F, 0x639B0DA6, 0x675A1011, 0x791D4014, 0x7DDC5DA3, 0x709F7B7A, 0x745E66CD
    , 0x9823B6E0, 0x9CE2AB57, 0x91A18D8E, 0x95609039, 0x8B27C03C, 0x8FE6DD8B, 0x82A5FB52, 0x8664E6E5
    , 0xBE2B5B58, 0xBAEA46EF, 0xB7A96036, 0xB3687D81, 0xAD2F2D84, 0xA9EE3033, 0xA4AD16EA, 0xA06C0B5D
    , 0xD4326D90, 0xD0F37027, 0xDDB056FE, 0xD9714B49, 0xC7361B4C, 0xC3F706FB, 0xCEB42022, 0xCA753D95
    , 0xF23A8028, 0xF6FB9D9F, 0xFBB8BB46, 0xFF79A6F1, 0xE13EF6F4, 0xE5FFEB43, 0xE8BCCD9A, 0xEC7DD02D
    , 0x34867077, 0x30476DC0, 0x3D044B19, 0x39C556AE, 0x278206AB, 0x23431B1C, 0x2E003DC5, 0x2AC12072
    , 0x128E9DCF, 0x164F8078, 0x1B0CA6A1, 0x1FCDBB16, 0x018AEB13, 0x054BF6A4, 0x0808D07D, 0x0CC9CDCA
    , 0x7897AB07, 0x7C56B6B0, 0x71159069, 0x75D48DDE, 0x6B93DDDB, 0x6F52C06C, 0x6211E6B5, 0x66D0FB02
    , 0x5E9F46BF, 0x5A5E5B08, 0x571D7DD1, 0x53DC6066, 0x4D9B3063, 0x495A2DD4, 0x44190B0D, 0x40D816BA
    , 0xACA5C697, 0xA864DB20, 0xA527FDF9, 0xA1E6E04E, 0xBFA1B04B, 0xBB60ADFC, 0xB6238B25, 0xB2E29692
    , 0x8AAD2B2F, 0x8E6C3698, 0x832F1041, 0x87EE0DF6, 0x99A95DF3, 0x9D684044, 0x902B669D, 0x94EA7B2A
    , 0xE0B41DE7, 0xE4750050, 0xE9362689, 0xEDF73B3E, 0xF3B06B3B, 0xF771768C, 0xFA325055, 0xFEF34DE2
    , 0xC6BCF05F, 0xC27DEDE8, 0xCF3ECB31, 0xCBFFD686, 0xD5B88683, 0xD1799B34, 0xDC3ABDED, 0xD8FBA05A
    , 0x690CE0EE, 0x6DCDFD59, 0x608EDB80, 0x644FC637, 0x7A089632, 0x7EC98B85, 0x738AAD5C, 0x774BB0EB
    , 0x4F040D56, 0x4BC510E1, 0x46863638, 0x42472B8F, 0x5C007B8A, 0x58C1663D, 0x558240E4, 0x51435D53
    , 0x251D3B9E, 0x21DC2629, 0x2C9F00F0, 0x285E1D47, 0x36194D42, 0x32D850F5, 0x3F9B762C, 0x3B5A6B9B
    , 0x0315D626, 0x07D4CB91, 0x0A97ED48, 0x0E56F0FF, 0x1011A0FA, 0x14D0BD4D, 0x19939B94, 0x1D528623
    , 0xF12F560E, 0xF5EE4BB9, 0xF8AD6D60, 0xFC6C70D7, 0xE22B20D2, 0xE6EA3D65, 0xEBA91BBC, 0xEF68060B
    , 0xD727BBB6, 0xD3E6A601, 0xDEA580D8, 0xDA649D6F, 0xC423CD6A, 0xC0E2D0DD, 0xCDA1F604, 0xC960EBB3
    , 0xBD3E8D7E, 0xB9FF90C9, 0xB4BCB610, 0xB07DABA7, 0xAE3AFBA2, 0xAAFBE615, 0xA7B8C0CC, 0xA379DD7B
    , 0x9B3660C6, 0x9FF77D71, 0x92B45BA8, 0x9675461F, 0x8832161A, 0x8CF30BAD, 0x81B02D74, 0x857130C3
    , 0x5D8A9099, 0x594B8D2E, 0x5408ABF7, 0x50C9B640, 0x4E8EE645, 0x4A4FFBF2, 0x470CDD2B, 0x43CDC09C
    , 0x7B827D21, 0x7F436096, 0x7200464F, 0x76C15BF8, 0x68860BFD, 0x6C47164A, 0x61043093, 0x65C52D24
    , 0x119B4BE9, 0x155A565E, 0x18197087, 0x1CD86D30, 0x029F3D35, 0x065E2082, 0x0B1D065B, 0x0FDC1BEC
    , 0x3793A651, 0x3352BBE6, 0x3E119D3F, 0x3AD08088, 0x2497D08D, 0x2056CD3A, 0x2D15EBE3, 0x29D4F654
    , 0xC5A92679, 0xC1683BCE, 0xCC2B1D17, 0xC8EA00A0, 0xD6AD50A5, 0xD26C4D12, 0xDF2F6BCB, 0xDBEE767C
    , 0xE3A1CBC1, 0xE760D676, 0xEA23F0AF, 0xEEE2ED18, 0xF0A5BD1D, 0xF464A0AA, 0xF9278673, 0xFDE69BC4
    , 0x89B8FD09, 0x8D79E0BE, 0x803AC667, 0x84FBDBD0, 0x9ABC8BD5, 0x9E7D9662, 0x933EB0BB, 0x97FFAD0C
    , 0xAFB010B1, 0xAB710D06, 0xA6322BDF, 0xA2F33668, 0xBCB4666D, 0xB8757BDA, 0xB5365D03, 0xB1F740B4 
  };

  uint32_t nTemp, nTmp;
  uint32_t i, n;

#if 1
  i = (uint32_t)len & 3U;
  len &= ~3U;
  for(n = 0U; n < (uint32_t)len; n+= 4U)
  {
    memcpy((void *)&nTmp, (const void *)&p_dat_u8[n], (uint32_t)4);         /* 拷贝4个字节 */
    crc ^= nTmp;                

    nTemp = st_a_CRCTable32[(uint8_t)(( crc >> 24U ) & 0xFFU)];    /* 取一个字节，查表 */
    crc <<= 8U;                                             /* 丢掉计算过的头一个BYTE */
    crc ^= nTemp;                                          /* 与前一个BYTE的计算结果异或 */

    nTemp = st_a_CRCTable32[(uint8_t)(( crc >> 24U ) & 0xFFU)];    /* 取一个字节，查表 */
    crc <<= 8U;                                             /* 丢掉计算过的头一个BYTE */
    crc ^= nTemp;                                          /* 与前一个BYTE的计算结果异或 */

    nTemp = st_a_CRCTable32[(uint8_t)(( crc >> 24U ) & 0xFFU)];    /* 取一个字节，查表 */
    crc <<= 8U;                                             /* 丢掉计算过的头一个BYTE */
    crc ^= nTemp;                                          /* 与前一个BYTE的计算结果异或 */

    nTemp = st_a_CRCTable32[(uint8_t)(( crc >> 24U ) & 0xFFU)];    /* 取一个字节，查表 */
    crc <<= 8U;                                             /* 丢掉计算过的头一个BYTE */
    crc ^= nTemp;                                          /* 与前一个BYTE的计算结果异或 */

  }
  if(i > 0U)
  {
    nTmp = 0U;
    memcpy((void *)&nTmp, (const void *)&p_dat_u8[n], i);     /* 拷贝剩余字节 */
    crc ^= nTmp;                

    nTemp = st_a_CRCTable32[(uint8_t)(( crc >> 24U ) & 0xFFU)];    /* 取一个字节，查表 */
    crc <<= 8U;                                             /* 丢掉计算过的头一个BYTE */
    crc ^= nTemp;                                          /* 与前一个BYTE的计算结果异或 */

    nTemp = st_a_CRCTable32[(uint8_t)(( crc >> 24U ) & 0xFFU)];    /* 取一个字节，查表 */
    crc <<= 8U;                                             /* 丢掉计算过的头一个BYTE */
    crc ^= nTemp;                                          /* 与前一个BYTE的计算结果异或 */

    nTemp = st_a_CRCTable32[(uint8_t)(( crc >> 24U ) & 0xFFU)];    /* 取一个字节，查表 */
    crc <<= 8U;                                             /* 丢掉计算过的头一个BYTE */
    crc ^= nTemp;                                          /* 与前一个BYTE的计算结果异或 */

    nTemp = st_a_CRCTable32[(uint8_t)(( crc >> 24U ) & 0xFFU)];    /* 取一个字节，查表 */
    crc <<= 8U;                                             /* 丢掉计算过的头一个BYTE */
    crc ^= nTemp;                                          /* 与前一个BYTE的计算结果异或 */
    
  }
  else
  {
    /* ntd */
  }
#else
  for(n = 0; n < len; n+= 4)
  {
    if(len - n >= 4)  
    {
      memcpy((void *)&nTmp, (void *)&pData[n], 4);         /* 拷贝4个字节 */
    }else{               
      nTmp = 0;
      memcpy((void *)&nTmp, (void *)&pData[n], len - n);     /* 拷贝剩余字节 */
    }
    crc ^= nTmp;                

    nTemp = st_a_CRCTable32[(uint8_t)(( crc >> 24 ) & 0xFF)];    /* 取一个字节，查表 */
    crc <<= 8;                                             /* 丢掉计算过的头一个BYTE */
    crc ^= nTemp;                                          /* 与前一个BYTE的计算结果异或 */

    nTemp = st_a_CRCTable32[(uint8_t)(( crc >> 24 ) & 0xFF)];    /* 取一个字节，查表 */
    crc <<= 8;                                             /* 丢掉计算过的头一个BYTE */
    crc ^= nTemp;                                          /* 与前一个BYTE的计算结果异或 */

    nTemp = st_a_CRCTable32[(uint8_t)(( crc >> 24 ) & 0xFF)];    /* 取一个字节，查表 */
    crc <<= 8;                                             /* 丢掉计算过的头一个BYTE */
    crc ^= nTemp;                                          /* 与前一个BYTE的计算结果异或 */

    nTemp = st_a_CRCTable32[(uint8_t)(( crc >> 24 ) & 0xFF)];    /* 取一个字节，查表 */
    crc <<= 8;                                             /* 丢掉计算过的头一个BYTE */
    crc ^= nTemp;                                          /* 与前一个BYTE的计算结果异或 */

  }
#endif
  return crc;
} 
/* enter */
#pragma pop



/**   
 * 初始值oldcrc32 = 0x5a5a5a5aL;
*/
uint32_t generate_CRC32(const uint8_t * p_dat_u8, uint32_t len, uint32_t oldcrc32)
{
  /** 多项式 0xEDB88320*/
  static const uint32_t st_a_crc_32_tab[256] =
  {
    0x00000000L, 0x77073096L, 0xEE0E612CL, 0x990951BAL, 0x076DC419L, 0x706AF48FL, 0xE963A535L, 0x9E6495A3L, 
    0x0EDB8832L, 0x79DCB8A4L, 0xE0D5E91EL, 0x97D2D988L, 0x09B64C2BL, 0x7EB17CBDL, 0xE7B82D07L, 0x90BF1D91L, 
    0x1DB71064L, 0x6AB020F2L, 0xF3B97148L, 0x84BE41DEL, 0x1ADAD47DL, 0x6DDDE4EBL, 0xF4D4B551L, 0x83D385C7L, 
    0x136C9856L, 0x646BA8C0L, 0xFD62F97AL, 0x8A65C9ECL, 0x14015C4FL, 0x63066CD9L, 0xFA0F3D63L, 0x8D080DF5L, 
    0x3B6E20C8L, 0x4C69105EL, 0xD56041E4L, 0xA2677172L, 0x3C03E4D1L, 0x4B04D447L, 0xD20D85FDL, 0xA50AB56BL, 
    0x35B5A8FAL, 0x42B2986CL, 0xDBBBC9D6L, 0xACBCF940L, 0x32D86CE3L, 0x45DF5C75L, 0xDCD60DCFL, 0xABD13D59L, 
    0x26D930ACL, 0x51DE003AL, 0xC8D75180L, 0xBFD06116L, 0x21B4F4B5L, 0x56B3C423L, 0xCFBA9599L, 0xB8BDA50FL, 
    0x2802B89EL, 0x5F058808L, 0xC60CD9B2L, 0xB10BE924L, 0x2F6F7C87L, 0x58684C11L, 0xC1611DABL, 0xB6662D3DL, 
    0x76DC4190L, 0x01DB7106L, 0x98D220BCL, 0xEFD5102AL, 0x71B18589L, 0x06B6B51FL, 0x9FBFE4A5L, 0xE8B8D433L, 
    0x7807C9A2L, 0x0F00F934L, 0x9609A88EL, 0xE10E9818L, 0x7F6A0DBBL, 0x086D3D2DL, 0x91646C97L, 0xE6635C01L, 
    0x6B6B51F4L, 0x1C6C6162L, 0x856530D8L, 0xF262004EL, 0x6C0695EDL, 0x1B01A57BL, 0x8208F4C1L, 0xF50FC457L, 
    0x65B0D9C6L, 0x12B7E950L, 0x8BBEB8EAL, 0xFCB9887CL, 0x62DD1DDFL, 0x15DA2D49L, 0x8CD37CF3L, 0xFBD44C65L, 
    0x4DB26158L, 0x3AB551CEL, 0xA3BC0074L, 0xD4BB30E2L, 0x4ADFA541L, 0x3DD895D7L, 0xA4D1C46DL, 0xD3D6F4FBL, 
    0x4369E96AL, 0x346ED9FCL, 0xAD678846L, 0xDA60B8D0L, 0x44042D73L, 0x33031DE5L, 0xAA0A4C5FL, 0xDD0D7CC9L, 
    0x5005713CL, 0x270241AAL, 0xBE0B1010L, 0xC90C2086L, 0x5768B525L, 0x206F85B3L, 0xB966D409L, 0xCE61E49FL, 
    0x5EDEF90EL, 0x29D9C998L, 0xB0D09822L, 0xC7D7A8B4L, 0x59B33D17L, 0x2EB40D81L, 0xB7BD5C3BL, 0xC0BA6CADL, 
    0xEDB88320L, 0x9ABFB3B6L, 0x03B6E20CL, 0x74B1D29AL, 0xEAD54739L, 0x9DD277AFL, 0x04DB2615L, 0x73DC1683L, 
    0xE3630B12L, 0x94643B84L, 0x0D6D6A3EL, 0x7A6A5AA8L, 0xE40ECF0BL, 0x9309FF9DL, 0x0A00AE27L, 0x7D079EB1L, 
    0xF00F9344L, 0x8708A3D2L, 0x1E01F268L, 0x6906C2FEL, 0xF762575DL, 0x806567CBL, 0x196C3671L, 0x6E6B06E7L, 
    0xFED41B76L, 0x89D32BE0L, 0x10DA7A5AL, 0x67DD4ACCL, 0xF9B9DF6FL, 0x8EBEEFF9L, 0x17B7BE43L, 0x60B08ED5L, 
    0xD6D6A3E8L, 0xA1D1937EL, 0x38D8C2C4L, 0x4FDFF252L, 0xD1BB67F1L, 0xA6BC5767L, 0x3FB506DDL, 0x48B2364BL, 
    0xD80D2BDAL, 0xAF0A1B4CL, 0x36034AF6L, 0x41047A60L, 0xDF60EFC3L, 0xA867DF55L, 0x316E8EEFL, 0x4669BE79L, 
    0xCB61B38CL, 0xBC66831AL, 0x256FD2A0L, 0x5268E236L, 0xCC0C7795L, 0xBB0B4703L, 0x220216B9L, 0x5505262FL, 
    0xC5BA3BBEL, 0xB2BD0B28L, 0x2BB45A92L, 0x5CB36A04L, 0xC2D7FFA7L, 0xB5D0CF31L, 0x2CD99E8BL, 0x5BDEAE1DL, 
    0x9B64C2B0L, 0xEC63F226L, 0x756AA39CL, 0x026D930AL, 0x9C0906A9L, 0xEB0E363FL, 0x72076785L, 0x05005713L, 
    0x95BF4A82L, 0xE2B87A14L, 0x7BB12BAEL, 0x0CB61B38L, 0x92D28E9BL, 0xE5D5BE0DL, 0x7CDCEFB7L, 0x0BDBDF21L, 
    0x86D3D2D4L, 0xF1D4E242L, 0x68DDB3F8L, 0x1FDA836EL, 0x81BE16CDL, 0xF6B9265BL, 0x6FB077E1L, 0x18B74777L, 
    0x88085AE6L, 0xFF0F6A70L, 0x66063BCAL, 0x11010B5CL, 0x8F659EFFL, 0xF862AE69L, 0x616BFFD3L, 0x166CCF45L, 
    0xA00AE278L, 0xD70DD2EEL, 0x4E048354L, 0x3903B3C2L, 0xA7672661L, 0xD06016F7L, 0x4969474DL, 0x3E6E77DBL, 
    0xAED16A4AL, 0xD9D65ADCL, 0x40DF0B66L, 0x37D83BF0L, 0xA9BCAE53L, 0xDEBB9EC5L, 0x47B2CF7FL, 0x30B5FFE9L, 
    0xBDBDF21CL, 0xCABAC28AL, 0x53B39330L, 0x24B4A3A6L, 0xBAD03605L, 0xCDD70693L, 0x54DE5729L, 0x23D967BFL, 
    0xB3667A2EL, 0xC4614AB8L, 0x5D681B02L, 0x2A6F2B94L, 0xB40BBE37L, 0xC30C8EA1L, 0x5A05DF1BL, 0x2D02EF8DL
  };

  uint32_t t; /* 临时变量 */
  
  while (len > 0U)  /* 剩余 */
  {
    t = (oldcrc32 ^ (uint32_t)(*p_dat_u8)) & (uint32_t)0xFFU;        /* 计算CRC*/
    oldcrc32 = (oldcrc32 >> 8U) ^ st_a_crc_32_tab[t]; /* 计算CRC*/
    len--;          /* 递减 */
    p_dat_u8++;     /* 指针变化 */
  } 
  return oldcrc32;    /* 返回CRC */
} 

#if 0
uint32_t convert_crc32_to_big_endian(uint32_t crc32)
{
  uint8_t b0, b1, b2, b3;

  crc32 = ~crc32;
#if 0
  b0 = crc32 & 0xFF;
  b1 = (crc32 >> 8) & 0xFF;
  b2 = (crc32 >> 16) & 0xFF;
  b3 = (crc32 >> 24) & 0xFF;

  /* crc32 = B4TOL(b3, b2, b1, b0); */
#endif
  return crc32;
}
#endif

#define CRC32_FIX_INITVAL   (0x5A5A5A5AL)
uint32_t crc32(const uint8_t * p_dat_u8, uint32_t len)
{
  return generate_CRC32(p_dat_u8, len, CRC32_FIX_INITVAL);
}

#define CRC32C_POLY (0x1EDC6F41)

#define CRC32C(c,d) ((c) =((c) >> 8) ^ crc_c[((c) ^ (d)) & 0xFF])

static unsigned long crc_c[256] =
{
 0x00000000L, 0xF26B8303L, 0xE13B70F7L, 0x1350F3F4L,

 0xC79A971FL, 0x35F1141CL, 0x26A1E7E8L, 0xD4CA64EBL,

 0x8AD958CFL, 0x78B2DBCCL, 0x6BE22838L, 0x9989AB3BL,

 0x4D43CFD0L, 0xBF284CD3L, 0xAC78BF27L, 0x5E133C24L,

 0x105EC76FL, 0xE235446CL, 0xF165B798L, 0x030E349BL,

 0xD7C45070L, 0x25AFD373L, 0x36FF2087L, 0xC494A384L,

 0x9A879FA0L, 0x68EC1CA3L, 0x7BBCEF57L, 0x89D76C54L,

 0x5D1D08BFL, 0xAF768BBCL, 0xBC267848L, 0x4E4DFB4BL,

 0x20BD8EDEL, 0xD2D60DDDL, 0xC186FE29L, 0x33ED7D2AL,

 0xE72719C1L, 0x154C9AC2L, 0x061C6936L, 0xF477EA35L,

 0xAA64D611L, 0x580F5512L, 0x4B5FA6E6L, 0xB93425E5L,

 0x6DFE410EL, 0x9F95C20DL, 0x8CC531F9L, 0x7EAEB2FAL,

 0x30E349B1L, 0xC288CAB2L, 0xD1D83946L, 0x23B3BA45L,

 0xF779DEAEL, 0x05125DADL, 0x1642AE59L, 0xE4292D5AL,

 0xBA3A117EL, 0x4851927DL, 0x5B016189L, 0xA96AE28AL,

 0x7DA08661L, 0x8FCB0562L, 0x9C9BF696L, 0x6EF07595L,

 0x417B1DBCL, 0xB3109EBFL, 0xA0406D4BL, 0x522BEE48L,

 0x86E18AA3L, 0x748A09A0L, 0x67DAFA54L, 0x95B17957L,

 0xCBA24573L, 0x39C9C670L, 0x2A993584L, 0xD8F2B687L,

 0x0C38D26CL, 0xFE53516FL, 0xED03A29BL, 0x1F682198L,

 0x5125DAD3L, 0xA34E59D0L, 0xB01EAA24L, 0x42752927L,

 0x96BF4DCCL, 0x64D4CECFL, 0x77843D3BL, 0x85EFBE38L,

 0xDBFC821CL, 0x2997011FL, 0x3AC7F2EBL, 0xC8AC71E8L,

 0x1C661503L, 0xEE0D9600L, 0xFD5D65F4L, 0x0F36E6F7L,

 0x61C69362L, 0x93AD1061L, 0x80FDE395L, 0x72966096L,

 0xA65C047DL, 0x5437877EL, 0x4767748AL, 0xB50CF789L,

 0xEB1FCBADL, 0x197448AEL, 0x0A24BB5AL, 0xF84F3859L,

 0x2C855CB2L, 0xDEEEDFB1L, 0xCDBE2C45L, 0x3FD5AF46L,

 0x7198540DL, 0x83F3D70EL, 0x90A324FAL, 0x62C8A7F9L,

 0xB602C312L, 0x44694011L, 0x5739B3E5L, 0xA55230E6L,

 0xFB410CC2L, 0x092A8FC1L, 0x1A7A7C35L, 0xE811FF36L,

 0x3CDB9BDDL, 0xCEB018DEL, 0xDDE0EB2AL, 0x2F8B6829L,

 0x82F63B78L, 0x709DB87BL, 0x63CD4B8FL, 0x91A6C88CL,

 0x456CAC67L, 0xB7072F64L, 0xA457DC90L, 0x563C5F93L,

 0x082F63B7L, 0xFA44E0B4L, 0xE9141340L, 0x1B7F9043L,

 0xCFB5F4A8L, 0x3DDE77ABL, 0x2E8E845FL, 0xDCE5075CL,

 0x92A8FC17L, 0x60C37F14L, 0x73938CE0L, 0x81F80FE3L,

 0x55326B08L, 0xA759E80BL, 0xB4091BFFL, 0x466298FCL,

 0x1871A4D8L, 0xEA1A27DBL, 0xF94AD42FL, 0x0B21572CL,

 0xDFEB33C7L, 0x2D80B0C4L, 0x3ED04330L, 0xCCBBC033L,

 0xA24BB5A6L, 0x502036A5L, 0x4370C551L, 0xB11B4652L,

 0x65D122B9L, 0x97BAA1BAL, 0x84EA524EL, 0x7681D14DL,

 0x2892ED69L, 0xDAF96E6AL, 0xC9A99D9EL, 0x3BC21E9DL,

 0xEF087A76L, 0x1D63F975L, 0x0E330A81L, 0xFC588982L,

 0xB21572C9L, 0x407EF1CAL, 0x532E023EL, 0xA145813DL,

 0x758FE5D6L, 0x87E466D5L, 0x94B49521L, 0x66DF1622L,

 0x38CC2A06L, 0xCAA7A905L, 0xD9F75AF1L, 0x2B9CD9F2L,

 0xFF56BD19L, 0x0D3D3E1AL, 0x1E6DCDEEL, 0xEC064EEDL,

 0xC38D26C4L, 0x31E6A5C7L, 0x22B65633L, 0xD0DDD530L,

 0x0417B1DBL, 0xF67C32D8L, 0xE52CC12CL, 0x1747422FL,

 0x49547E0BL, 0xBB3FFD08L, 0xA86F0EFCL, 0x5A048DFFL,

 0x8ECEE914L, 0x7CA56A17L, 0x6FF599E3L, 0x9D9E1AE0L,

 0xD3D3E1ABL, 0x21B862A8L, 0x32E8915CL, 0xC083125FL,

 0x144976B4L, 0xE622F5B7L, 0xF5720643L, 0x07198540L,

 0x590AB964L, 0xAB613A67L, 0xB831C993L, 0x4A5A4A90L,

 0x9E902E7BL, 0x6CFBAD78L, 0x7FAB5E8CL, 0x8DC0DD8FL,

 0xE330A81AL, 0x115B2B19L, 0x020BD8EDL, 0xF0605BEEL,

 0x24AA3F05L, 0xD6C1BC06L, 0xC5914FF2L, 0x37FACCF1L,

 0x69E9F0D5L, 0x9B8273D6L, 0x88D28022L, 0x7AB90321L,

 0xAE7367CAL, 0x5C18E4C9L, 0x4F48173DL, 0xBD23943EL,

 0xF36E6F75L, 0x0105EC76L, 0x12551F82L, 0xE03E9C81L,

 0x34F4F86AL, 0xC69F7B69L, 0xD5CF889DL, 0x27A40B9EL,

 0x79B737BAL, 0x8BDCB4B9L, 0x988C474DL, 0x6AE7C44EL,

 0xBE2DA0A5L, 0x4C4623A6L, 0x5F16D052L, 0xAD7D5351L,

 };

/*********************************************************
 * 功能：计算SCTP标准的CRC32校验码，多项式0x1EDC6F41
 * 参数：*pbuffer_u8-待计算数据缓冲区指针
 * 参数：length_u32 -待计算数据字节数
 * 参数：initval_u32-初始值
 * 返回：
 **********************************************************/
uint32_t crc32c(uint8_t *pbuffer_u8, uint32_t length_u32, uint32_t initval_u32)
{
 uint32_t i;
 uint32_t crc32_u32 = initval_u32;

 for (i = 0; i < length_u32; i++)
 {
   CRC32C(crc32_u32, pbuffer_u8[i]);
 }
 return crc32_u32;
}


/** End of file */

